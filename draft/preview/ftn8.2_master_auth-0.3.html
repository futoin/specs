<!DOCTYPE html>
<html>
<head>
<title>ftn8.2_master_auth.md</title>
<link rel="stylesheet" type="text/css" href="../../css/specs.css">
</head><body>
<pre>
FTN8.3: FutoIn Security Concept - Master Secret Authentication
Version: 0.3DV
Date: 2018-05-18
Copyright: 2014-2018 FutoIn Project (http://futoin.org)
Authors: Andrey Galkin
</pre>

<h1>CHANGES</h1>
<ul>
<li>v0.3 - 2018-05-18 - Andrey Galkin<ul>
<li>CHANGED: revised with implementation</li>
</ul>
</li>
<li>v0.2 - 2017-12-30 - Andrey Galkin<ul>
<li>CHANGED: heavily revised &amp; split into sub-specs</li>
</ul>
</li>
<li>v0.1 - 2014-06-03 - Andrey Galkin<ul>
<li>Initial draft</li>
</ul>
</li>
</ul>
<h1>1. Intro</h1>
<p>This sub-specification of <a href="./ftn8_security_concept.html">FTN8</a> covers
more secure Master Secret Authentication with dynamically updated shared secrets.</p>
<p>Service is assumed to be a B2B software or equal - high number of
unattended requests.</p>
<h1>2. Concept</h1>
<h2>2.1. Overall idea</h2>
<ol>
<li>Strong symmetric master key is assumed under "Secret".</li>
<li>Use approach to exchange keys based on temporary assymetric key generated by Service.<ul>
<li>RSA 2048/4096-bit with ephemeral key as safe default.</li>
<li>ECDHE (Elliptic Curve Diffie-Hellman Ephemeral) with Curve25519 and Curve448 as soon
    as it is finally widespread in most crypto libraries.</li>
</ul>
</li>
<li>Ensure assymetric key authenticity based transport security and/or
    existing shared Secret.</li>
<li>Ensure temporary key and new Secret quality by AuthService.</li>
<li>Use one of supported key derivation strategies:<ul>
<li>do not lock on one method,</li>
<li>allow tradeoff between performance and extra security at use time.</li>
</ul>
</li>
<li>Secret exchange interval solely depends on Invoker, but AuthService
    may deactivate too old or too used keys (defined by configuration).</li>
</ol>
<h2>2.2. Secure Master Secret exchange</h2>
<ol>
<li>Service makes initial call:<ul>
<li>generates a temporary assymetric key,</li>
<li>requests a new Master Secret from AuthService providing:<ul>
<li>the temporary public key for response encryption,</li>
<li>current active Master Secret ID as part of MAC.</li>
</ul>
</li>
</ul>
</li>
<li>AuthService processes the request:<ul>
<li>ensures request is authentic based on MAC signature,</li>
<li>generates a new Secret,</li>
<li>cleans up old secrets ensuring current active Master Secret ID remains,</li>
<li>sends back the new Master Secret encrypted by the temporary public key.</li>
</ul>
</li>
<li>Service processes response:<ul>
<li>decrypts the payload using the temporary private key,</li>
<li>injects the new Master Secret as primary.</li>
</ul>
</li>
<li>Service gradually starts using the new Secret.</li>
<li>Both the new Secret and the previous Secret are active.</li>
</ol>
<p>Goals met:</p>
<ul>
<li>Forward secrecy even if any secret gets compromised.</li>
<li>Works over unencrypted/untrusted channels, but it is discouraged.</li>
<li>Ensure rolling Secret updates without communication interruptions.</li>
<li>AuthService controls Secret quality.</li>
<li>Resource-heavy assymetric key generation is responsibility of Service to
  protect AuthService of heavy load.</li>
<li>Initiating Service (acting as Invoker) is responsible for periodic
  Master Secret exchange.<ul>
<li>It may not do that at all to reduce complexity, if static key is acceptable.</li>
<li>It avoids overcomplicating design with AuthService-to-Service callbacks.</li>
</ul>
</li>
</ul>
<h2>2.3 "sec" field structured format</h2>
<p class="futoin-schema">Schema: futoin-sec-master-mac</p>

<pre><code>{
    "title" : "FutoIn 'sec' field - Master MAC",
    "type" : "object",
    "additionalProperties" : false,
    "required" : [ "msid", "algo", "kds", "sig" ],
    "properties" : {
        "msid" : {
            "type" : "string",
            "description" : "Unique Master Secret ID"
        },
        "algo" : {
            "type" : "string",
            "description" : "MAC algo name as defined in FTN8"
        },
        "kds" : {
            "type" : "string",
            "description" : "Key Derivation Strategy"
        },
        "prm" : {
            "type" : "string",
            "description" : "KDS parameter, if applicable"
        },
        "sig" : {
            "type" : "string",
            "description" : "Base64 encoded MAC"
        }
    }
}
</code></pre>
<h2>2.4 "sec" field string format</h2>
<p><code>"-mmac:{msid}:{algo}:{dks}:{prm}:{sig}"</code></p>
<h2>2.5. Master MAC response "sec" field</h2>
<p>Response must be authenticated by the same Secret and the same hash algorithm
as used for request signing. Only signature has to be sent.</p>
<h2>2.6. Master MAC security level</h2>
<p><code>PrivilegedOps</code> security level must be assigned.</p>
<h2>2.7. Optional Master Secret Scope</h2>
<p>User/Service is in control of its own privacy vs. simplicity. There is an optional,
<code>scope</code> parameter for new Master Secret generation.</p>
<p>Peer Service must not be able to get derived key for particular Master Secret directly.
It must be possible only if invoking Service signs any message with particular derived key -
implicit approval to provide Derived Key to particular Service.</p>
<p>Only Master Secret with empty or matching <code>scope</code> must be accepted for new Secret
exchange to mitigate unauthorized access with Master Secret recovered from scoped
derived key. So, Master Secret with empty <code>scope</code> is seen as "main".</p>
<p>There are various options:</p>
<ol>
<li>Use one global Master Secret with high risk of its recovery through derived key.</li>
<li>Use several Master Secrets per peer service vendor.</li>
<li>Use a separate Master Secret per each peer.</li>
</ol>
<h2>2.8. Events</h2>
<ul>
<li><code>MSTR_NEW</code> - new master secret<ul>
<li><code>user</code> - LocalUserID</li>
<li><code>key_id</code> - MasterSecretID</li>
<li><code>scope</code> - key scope</li>
</ul>
</li>
<li><code>MSTR_DEL</code> - master secret delete<ul>
<li><code>key_id</code> - LocalUserID</li>
<li><code>id</code> - MasterSecretID</li>
</ul>
</li>
</ul>
<h1>3. Interface</h1>
<h2>3.1. Message authentication</h2>
<p>Provide Master Secret based authentication to Executor.</p>
<p>It is designed the way when MAC secret is always kept inside AuthService to
minimize risk of exposure.</p>
<pre><code>{
    "iface" : "futoin.auth.master",
    "version" : "{ver}",
    "ftn3rev" : "1.9",
    "imports" : [
        "futoin.ping:1.0",
        "futoin.auth.types:{ver}"
    ],
    "types" : {
        "KDSParam" : {
            "type" : "string",
            "regex" : "^[a-zA-Z0-9._/+-]{1,32}$"
        },
        "MACSecField" : {
            "type" : "map",
            "fields" : {
                "msid" : "MasterSecretID",
                "algo" : "MACAlgo",
                "kds" : "KeyDerivationStrategy",
                "prm" : {
                    "type" : "KDSParam",
                    "optional" : true
                },
                "sig" : "MACValue"
            }
        },
        "CipherType" : {
            "type" : "GenericIdentifier",
            "minlen" : 1,
            "maxlen" : 32
        },
        "CipherMode" : {
            "type" : "string",
            "regex" : "^[A-Z0-9][A-Z0-9_]{1,14}[A-Z0-9]$",
            "desc" : "CBC, CTR, GCM, CFB and others"
        }
    },
    "funcs" : {
        "checkMAC" : {
            "params" : {
                "base" : "MACBase",
                "sec" : "MACSecField",
                "source" : "ClientFingerprints"
            },
            "result" : "AuthInfo",
            "throws" : [
                "SecurityError"
            ]
        },
        "genMAC" : {
            "params" : {
                "base" : "MACBase",
                "reqsec" : "MACSecField"
            },
            "result" : "MACValue",
            "throws" : [
                "SecurityError"
            ]
        },
        "exposeDerivedKey" : {
            "params" : {
                "base" : "MACBase",
                "sec" : "MACSecField",
                "source" : "ClientFingerprints"
            },
            "result" : {
                "auth" : "AuthInfo",
                "prm" : "KDSParam",
                "etype" : "CipherType",
                "emode" : "CipherMode",
                "ekey" : "EncryptedKey"
            },
            "throws" : [
                "SecurityError"
            ],
            "desc" : "Feature to support local key cache"
        },
        "getNewEncryptedSecret" : {
            "params" : {
                "type" : "ExchangeKeyType",
                "pubkey" : "ExchangeKey",
                "scope" : {
                    "type" : "MasterScope",
                    "default" : null
                }
            },
            "result" : {
                "id" : "MasterSecretID",
                "esecret" : "EncryptedMasterSecret"
            },
            "throws" : [
                "SecurityError",
                "NotSupportedKeyType"
            ]
        }
    },
    "requires" : [
        "SecureChannel",
        "MessageSignature",
        "BinaryData"
    ]
}
</code></pre>
<h2>3.2. Auto registration</h2>
<p>This interface allow anonymous access and should be disabled by default
configuration.</p>
<p>TBD.</p>
<pre><code>{
    "iface" : "futoin.auth.master.register",
    "version" : "{ver}",
    "ftn3rev" : "1.9",
    "imports" : [
        "futoin.ping:1.0",
        "futoin.auth.types:{ver}"
    ],
    "funcs" : {
    },
    "requires" : [
        "SecureChannel",
        "AllowAnonymous"
    ]
}
</code></pre>
<h2>3.3. Management</h2>
<p>This one is complementary to "futoin.auth.manage" iface.</p>
<pre><code>{
    "iface" : "futoin.auth.master.manage",
    "version" : "{ver}",
    "ftn3rev" : "1.9",
    "imports" : [
        "futoin.ping:1.0",
        "futoin.auth.types:{ver}"
    ],
    "funcs" : {
        "getNewPlainSecret" : {
            "params" : {
                "user" : "LocalUserID"
            },
            "result" : {
                "id" : "MasterSecretID",
                "secret" : "Base64"
            },
            "throws" : [
                "UnknownUser",
                "NotSet"
            ],
            "seclvl" : "System"
        }
    },
    "requires" : [
        "SecureChannel",
        "MessageSignature"
    ]
}
</code></pre>
<p>=END OF SPEC=</p>
</body></html>